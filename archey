#!/usr/bin/env python
#
# archey [version 0.2.2]
#
# Maintained by Melik Manukyan <melik@archlinux.us>
# Distributed under the terms of the GNU General Public License v3.
# See http://www.gnu.org/licenses/gpl.txt for the full license text.
#
# System information tool for Archlinux written in python.

# Import libraries
import os, sys, subprocess, optparse, re
from subprocess import Popen, PIPE
from optparse import OptionParser
from getpass import getuser
from time import ctime, sleep

# Display [Comment/Uncomment to Enable/Disable information.]
display = [
 'os', # Display Operating System
 'hostname', # Display Machine Hostname
 'kernel',  # Display Kernel Version
 'uptime',  # Display System Uptime
 'wm',  # Display Window Manager
 'de', # Display Desktop Environment
 'packages', # Display Number of Packages Installed
 'ram', # Display RAM Usage
 'cpu', # Display CPU Model
 'sh', # Display Current Shell
 'term', # Display Current Terminal
 'fs' # Display / Partition Usage
 ]

# Array containing Values
result = []

# Options
if __name__=='__main__':
 parser = OptionParser(usage='%prog [-c COLOR] [-s, --screenshot]', description='To customize the info displayed on archey, edit "/usr/bin/archey" directly and look for the display array. Note: Archey can only allow up to 15 fields.', version="%prog 0.2.2")
 parser.add_option('-c',
  action='store', default='blue', type='choice', dest='color', choices=('black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'), help='choose a color: black, red, green, yellow, blue, magenta, cyan, white [Default: blue]')
 parser.add_option('-s', '--screenshot',
  action='store_true', dest='screenshot', help='take a screenshot')
 (options, args) = parser.parse_args()

# Define colors
colorscheme = '%s' % options.color
colors = {'black': '0', 'red': '1', 'green': '2', 'yellow': '3', 'blue': '4', 'magenta': '5', 'cyan': '6', 'white': '7'}
for key in colors.keys():
 if key in colorscheme: colorcode = colors[key]    
color = '\x1b[1;3%sm' % colorcode
color2 = '\x1b[0;3%sm' % colorcode
clear = '\x1b[0m'

# Define processes for identifying Desktop Environmentss, Window Managers, Shells.
de_dict = {
 'gnome-session': 'GNOME',
 'ksmserver': 'KDE',
 'xfconfd': 'Xfce'}
           
wm_dict = {
 'awesome': 'Awesome',
 'beryl': 'Beryl',
 'blackbox': 'Blackbox',
 'compiz': 'Compiz',
 'dwm': 'DWM',
 'enlightenment': 'Enlightenment',
 'fluxbox': 'Fluxbox',
 'fvwm': 'FVWM',
 'i3': 'i3',
 'icewm': 'IceWM',
 'kwin': 'KWin',
 'metacity': 'Metacity',
 'musca': 'Musca',
 'openbox': 'Openbox',
 'pekwm': 'PekWM',
 'ratpoison': 'ratpoison',
 'scrotwm': 'ScrotWM',
 'wmaker': 'Window Maker',
 'wmfs': 'Wmfs',
 'wmii': 'wmii',
 'xfwm4': 'Xfwm',
 'xmonad': 'xmonad'}

sh_dict = {
 'zsh': 'Zsh',
 'bash': 'Bash',
 'dash': 'Dash',
 'fish': 'Fish',
 'ksh': 'Ksh',
 'csh': 'Csh',
 'jsh': 'Jsh',
 'tcsh': 'Tcsh'}

# Find running processes.
def xmonadfix(str):
 if re.compile("xmonad").match(str): return "xmonad"
 return str
p1 = Popen(['ps', '-u', getuser()], stdout=PIPE).communicate()[0].split('\n')
processes = map(xmonadfix, [process.split()[3] for process in p1 if process])
p1 = None

# Print coloured key with normal value.
def output(key, value):
 output = '%s%s:%s %s' % (color, key, clear, value)
 result.append(output)

# RAM Function
def ram_display():
 raminfo = Popen(['free', '-m'], stdout=PIPE).communicate()[0].split('\n')
 ram = ''.join(filter(re.compile('M').search, raminfo)).split()
 used = int(ram[2]) - int(ram[5]) - int(ram[6])
 output ('RAM', '%s MB / %s MB' % (used, ram[1]))

# Screenshot Function 
screen = '%s' % options.screenshot
def screenshot():
 print 'Taking shot in',
 list = range(1,6)
 list.reverse()
 for x in list:
   print '%s..' % x,
   sys.stdout.flush()
   sleep(1)
 print 'Say Cheeze!'
 subprocess.check_call(['scrot'])

# Operating System Function
def os_display(): 
 arch = Popen(['uname', '-m'], stdout=PIPE).communicate()[0].rstrip('\n')
 os = 'Arch Linux %s' % (arch)
 output('OS', os)

# Kernel Function
def kernel_display():
 kernel = Popen(['uname', '-r'], stdout=PIPE).communicate()[0].rstrip('\n')
 output ('Kernel', kernel)

# Hostname Function
def hostname_display():
 hostname = Popen(['uname', '-n'], stdout=PIPE).communicate()[0].rstrip('\n')
 output ('Hostname', hostname)

# CPU Function
def cpu_display():
 file = open('/proc/cpuinfo').readlines()
 cpuinfo = re.sub('  +', ' ', file[4].replace('model name\t: ', '').rstrip('\n'))
 output ('CPU', cpuinfo) 

# Uptime Function
def uptime_display():
 fuptime = int(open('/proc/uptime').read().split('.')[0])
 day = int(fuptime / 86400)
 fuptime = fuptime % 86400
 hour = int(fuptime / 3600)
 fuptime = fuptime % 3600
 minute = int(fuptime / 60)
 uptime = ''
 if day == 1:
  uptime += '%d day, ' % day
 if day > 1:
  uptime += '%d days, ' % day
 uptime += '%d:%02d' % (hour, minute)
 output('Uptime', uptime)

# Desktop Environment Function 
def de_display():
 de = 'None found'
 for key in de_dict.keys():
  if key in processes:
   de = de_dict[key]
   output ('Desktop Environment', de)

# Window Manager Function
def wm_display():
 wm = 'None found'
 for key in wm_dict.keys():
  if key in processes:
   wm = wm_dict[key]
   output ('Window Manager', wm)

# Shell Function
def sh_display():
 sh = os.getenv("SHELL").split('/')[-1].capitalize()
 output ('Shell', sh)

# Terminal Function
def term_display():
 term = os.getenv("TERM").split('/')[-1].capitalize()
 output ('Terminal', term)

# Packages Function
def packages_display():
 p1 = Popen(['pacman', '-Q'], stdout=PIPE)
 p2 = Popen(['wc', '-l'], stdin=p1.stdout, stdout=PIPE)
 packages = p2.communicate()[0].rstrip('\n')
 output ('Packages', packages)

# File System Function
def fs_display():
 supported = ('ext2', 'ext3', 'ext4', 'reiserfs', 'jfs', 'ntfs', 'fat32', 'btrfs')
 p1 = Popen(['df', '-TPh'], stdout=PIPE).communicate()[0]
 filesystems = p1.rstrip().split('\n')
 del filesystems[0]

 for fs in filesystems:
  fs_split = fs.split()
  used = fs_split[3]
  total = fs_split[2]
  type = fs_split[1]
  name = fs_split[6]
  part = '%s / %s (%s)' % (used, total, type)
  if name == '/': name = '/root'
  fs = name.rpartition('/')[2].title() + " FS"
  if type in supported:
   output (fs, part)

# Run functions found in 'display' array.
for x in display:
 funcname=x+'_display'
 func=locals()[funcname]
 func()

# Array containing values.
result.extend(['']*(20 - len(display)))

###### Result #######
print """%s
%s               +                %s
%s               #                %s
%s              ###               %s
%s             #####              %s
%s             ######             %s
%s            ; #####;            %s
%s           +##.#####            %s
%s          +##########           %s
%s         ######%s#####%s##;         %s
%s        ###%s############%s+        %s
%s       #%s######   #######        %s
%s     .######;     ;###;`\".      %s
%s    .#######;     ;#####.       %s
%s    #########.   .########`     %s
%s   ######'           '######    %s
%s  ;####                 ####;   %s
%s  ##'                     '##  %s 
%s #'                         `#  %s
%s """ % (color, color, result[0], color, result[1], color, result[2], color, result[3], color, result[4], color, result[5], color, result[6], color, result[7], color, color2, color, result[8], color, color2, color, result[9], color, color2, result[10], color2, result[11], color2, result[12], color2, result[13], color2, result[14], color2, result[15], color2, result[16], color2, result[17], clear)

if screen == 'True':
 screenshot()
