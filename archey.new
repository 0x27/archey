#!/usr/bin/env python
#
# Archey [version 0.3.0]
#
# Archey is a simple system information tool written in Python.
#
# Copyright 2010 Melik Manukyan <melik@archlinux.us>
#
# ASCII art by Brett Bohnenkamper <kittykatt@silverirc.com>
# Changes Jerome Launay <jerome@projet-libre.org>
# Fedora support by YeOK <yeok@henpen.org>
#
# Distributed under the terms of the GNU General Public License v3.
# See http://www.gnu.org/licenses/gpl.txt for the full license text.

# Import libraries
import os, sys, subprocess, optparse, re, linecache
from optparse import OptionParser
from getpass import getuser
from time import ctime, sleep

#---------------Output---------------#

output = [
 'User',
 'Hostname',
 'Distro',
 'Kernel',
 'Uptime',
 'WindowManager',
 'DesktopEnvironment',
 'Shell',
 'Terminal',
 'Packages',
 'CPU',
 'RAM',
 'Disk'
 ]

#--------------Exceptions-------------#

class ArcheyException(Exception): pass
 
#---------------Dictionaries---------------#

class NoDeleteDict(dict):
	"""
	This dict silently disables deletions. This is because allthough we will want users to be able to
	edit these dicts from their config files, we don't want them to muck up somthing important, so we
	disable deletions to protect them from themselves.
	
	>>>dic = NoDeleteDict({'a':1, 'b':2})
	
	We can still access items normally:
	>>>dic['a']
	1
	
	But when we delete items, nothing happens:
	>>>del dic['b']
	>>>dic['b']
	2
	"""
	
	def __delitem__(self, name):
		return

COLOR_DICT = NoDeleteDict({
	'Arch Linux': ['\x1b[0;34m', '\x1b[1;34m'],
	'Ubuntu': ['\x1b[0;31m', '\x1b[1;31m', '\x1b[0;33m'],
	'Debian': ['\x1b[0;31m', '\x1b[1;31m'],
	'Mint': ['\x1b[0;32m', '\x1b[1;37m'],
	'Crunchbang': ['\x1b[1;37m'],
	'Fedora': ['\x1b[0;34m', '\x1b[1;37m'],
	'Clear': '\x1b[0m'
	})
	
DE_DICT = NoDeleteDict({
	'gnome-session': 'GNOME',
	'ksmserver': 'KDE',
	'xfce4-session': 'Xfce',
	'lxsession': 'LXDE'
	})

WM_DICT = NoDeleteDict({
	'awesome': 'Awesome',
	'beryl': 'Beryl',
	'blackbox': 'Blackbox',
	'compiz': 'Compiz',
	'dwm': 'DWM',
	'enlightenment': 'Enlightenment',
	'fluxbox': 'Fluxbox',
	'fvwm': 'FVWM',
	'i3': 'i3',
	'icewm': 'IceWM',
	'kwin': 'KWin',
	'metacity': 'Metacity',
	'musca': 'Musca',
	'openbox': 'Openbox',
	'pekwm': 'PekWM',
	'ratpoison': 'ratpoison',
	'scrotwm': 'ScrotWM',
	'wmaker': 'Window Maker',
	'wmfs': 'Wmfs',
	'wmii': 'wmii',
	'xfwm4': 'Xfwm',
	'xmonad': 'xmonad'
	})


LOGO_DICT = NoDeleteDict({'Arch Linux': '''{color[1]}
{color[1]}               +                {results[0]}
{color[1]}               #                {results[1]}
{color[1]}              ###               {results[2]}
{color[1]}             #####              {results[3]}
{color[1]}             ######             {results[4]}
{color[1]}            ; #####;            {results[5]}
{color[1]}           +##.#####            {results[6]}
{color[1]}          +##########           {results[7]}
{color[1]}         ######{color[0]}#####{color[1]}##;         {results[8]}
{color[1]}        ###{color[0]}############{color[1]}+        {results[9]}
{color[1]}       #{color[0]}######   #######        {results[10]}
{color[0]}     .######;     ;###;`\".      {results[11]}
{color[0]}    .#######;     ;#####.       {results[12]}
{color[0]}    #########.   .########`     {results[13]}
{color[0]}   ######'           '######    {results[14]}
{color[0]}  ;####                 ####;   {results[15]}
{color[0]}  ##'                     '##   {results[16]} 
{color[0]} #'                         `#  {results[17]}
\x1b[0m'''})

PROCESSES = str(subprocess.check_output(('ps', '-u', getuser(), '-o', 'comm',
	'--no-headers')), encoding='utf8').rstrip('\n').split('\n')

		
def detect_distro():
	if os.path.exists('/etc/pacman.conf'):
		return 'Arch Linux'
	else:
		raise ArcheyException("Unsupported distro")
	
DISTRO = detect_distro()

#---------------Classes---------------#

class Output(list):
	
	def _color(self, index):
		"""
		Returns the escape code for either:
		a) The color scheme of the distro value stored in self.distro
		or
		b) The value of the entry in COLOR_DICT for the key passed
		
		>>out = Output()
		>>out._color(1) == COLOR_DICT[out.distro][1]
		>>out._color(out.distro) == COLOR_DICT[out.distro]
		"""
		
		if isinstance(index, str):
			return COLOR_DICT[index]
		return COLOR_DICT[DISTRO][index]
	
	def _get_logo(self):
		return LOGO_DICT[DISTRO]
	
	def _center_results(self, results, max_length=17):
		"""
		Centers a list of results. Length of desired list can be given via max_length kwarg.
		
		>>>out = Output()
		>>>out._center_results([1])
		[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 1, ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']
		>>>out._center_results([1], max_length=3)
		[' ', 1, ' ']
		"""
		
		length = len(results)
		if length > max_length:
			return results[:max_length + 1]
		
		center = int(max_length/2)
		start = int(center - length/2)
		new_results = list(' ' * max_length)
		new_results[start:start + length - 1] = results
		
		return new_results
	
	def _get_results(self):
		"""
		Returns a dict of the keys and values of the currently registered display classes.
		NOTE: Will not include any key value pairs where either evaluates to False.
		
		>>>out = Output()
		>>>class TestDisplay():
		...    key = 'Foo'
		...    value = 'Bar'
		...    key_value_pair = lambda self: {self.key: self.value}
		...
		>>>out.append(TestDisplay())
		>>>out._get_results()
		{'Foo': 'Bar'}
		"""
		return {key:value for key, value in [disp.key_value_pair() for disp in self] if key and value}
		
	def output(self):
		"""
		Outputs the archey logo and information. Reads Display classes from the internal list,
		and formats them, adding color. The final pretty list is then centered (though other alignments
		may be added) and printed.
		"""
		
		results = self._get_results()
		
		unformatted_stn = '{color}{key}: {clear}{value}{clear}'
		pretty_results = []
		for key, value in results.items():
			try:
				formatted_stn = unformatted_stn.format(color=self._color(1), key=key, value=value,
				                                       clear=self._color('Clear'))
			except:
				#Fail silently, have a debug option later for noisy fail?
				pass
			else:
				pretty_results.append(formatted_stn)
		
		centered_results = self._center_results(pretty_results)
		print(self._get_logo().format(color=self._color(DISTRO), results=centered_results))

class BaseDisplay():
	"""
	All display classes should inherit this. It defigns several base functions that can be overwritten by any child classes
	
	>>>import random
	>>>class RandomNumber(BaseDisplay):
	...    key = 'Random Number'
	...    value = random.random() * 1000
	...
	>>>r = RandomNumber()
	>>>print `r`
	"""
	
	key = None
	value = None
	
	def __repr__(self):
		return '<{0}: key={1}, value={2}>'.format(self.__class__.__name__, self.key, self.value)
	
	def get_key(self):
		"""
		Return the value of the class' key attribute. If classes wish to customise key generation,
		they should override this method
		"""
		return self.key
	
	def get_value(self):
		"""
		Return the value of the class' value attribute. If classes wish to customise value generation,
		they should override this method
		"""
		return self.value
	
	def key_value_pair(self):
		"""
		Returns a tuple of the key and value of the current display.
		
		>>>disp = BaseDisplay()
		>>>disp.key = 'Foo'
		>>>disp.value = 'Bar'
		>>>disp.key_value_pair()
		('Foo', 'Bar')
		"""
		return (self.get_key(), self.get_value())

#class Hostname:
#	def __init__(self):
			
#class Distro:
#	def __init__(self):
			
#class Kernel:
#	def __init__(self):
			
class Uptime(BaseDisplay):
	key = 'Uptime'
	
	def get_uptime(self):
		fuptime = int(open('/proc/uptime').read().split('.')[0])
		day = int(fuptime / 86400)
		fuptime = fuptime % 86400
		hour = int(fuptime / 3600)
		fuptime = fuptime % 3600
		minute = int(fuptime / 60)
		
		return {'day': day, 'hour': hour, 'minute': minute}
	
	def get_value(self):
		uptime = self.get_uptime()
		
		if uptime['day']:
			value = '{day}{suffix}'.format(day=uptime['day'], suffix='s' if day > 1 else '')
		else:
			value = ''
		value += '{hours}:{mins:02d}'.format(hours=uptime['hour'], mins=uptime['minute'])
		return value
	
class WindowManager(BaseDisplay):
	key = 'Window Manager'
	
	def get_value(self):
		wm = ''
		for key in WM_DICT.keys():
			if key in PROCESSES:
				wm = WM_DICT[key]
				break
					
		return wm
			
class DesktopEnvironment(BaseDisplay):
	key = 'Desktop Environment'
	
	def get_value(self):
		de = ''
		for key in DE_DICT.keys():
			if key in PROCESSES:
				wm = WM_DICT[key]
				break
		return wm
		
def enviroment_variable(klass):
	"""
	Decorate classes with this decorator. Classes decorated with enviroment_variable will
	have their __init__ function automaticly generated. This makes it very easy to write
	a class that returns an enviroment variable.
	
	>>>@enviroment_variable
	...class Lang():
	...    key = 'Language'
	...    env = 'LANG'
	...
	>>>test = Lang()
	>>>import os
	>>>assert test.value == os.getenv('LANG')
	"""
	
	def get_value(self):
		return os.getenv(self.env)
		
	if hasattr(klass, 'key') and hasattr(klass, 'env'):
		klass.get_value = get_value
	else:
		raise ArcheyException('Classes decorated with @enviroment_variable must have'
		                      'key and env attributes')
	
	return klass

@enviroment_variable
class Shell(BaseDisplay):
	key = 'Shell'
	env = 'SHELL'

@enviroment_variable	
class Terminal(BaseDisplay):
	key = 'Terminal'
	env = 'TERM'

@enviroment_variable
class User(BaseDisplay):
	key = 'User'
	env = 'USER'

def shell_command(klass):
	"""
	A class decorated with @shell_command will be treated as a class that runs a command, and then parses the output.
	
	It should have two string members, "command", the command that will be run, and "key", the key for the display.
	It should also implement one method, process_output, which should take two arguments, stdout, and stderr, and return
	a value to be displayed.
	"""
	def get_value(self):
		cmd = subprocess.Popen(self.command.split(),
		                       stdout=subprocess.PIPE,
		                       stdin=subprocess.PIPE,
		                       stderr=subprocess.PIPE)
		stdout, stderr = cmd.communicate()
		return self.process_output(stdout.decode('ascii'), stderr.decode('ascii'))
	
	if not all(hasattr(klass, name) for name in ('command', 'key', 'process_output')):
		raise ArcheyException("Classes decorated with @shell_command must have "
			              "a key and command attributes, and the process_output method")
	else:
		klass.get_value = get_value
	
	return klass

@shell_command
class Packages(BaseDisplay):
	key = 'Packman packages'
	command = 'pacman -Q'
	
	def process_output(self, stdout, stderr):
		#Return nothing if pacman returns errors
		if stderr:
			return None
		
		no_of_packages = len(stdout.split('\n'))
		
		return str(no_of_packages)
	
			
#class CPU():
#	def __init__(self):
			
#class RAM():
#	def __init__(self):
			
#class Disk():
#	def __init__(self):


## TEST ## <<< TEMPORARY 
def main():
	out = Output()
	out.append(Shell())
	out.append(User())
	out.append(Terminal())
	out.append(Uptime())
	out.append(WindowManager())
	out.append(Packages())
	#out.append(DesktopEnvirornment())
	out.output()

if __name__ == '__main__':
	main()
